<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        function assignLightmapOnMaterial(material, lightmap) {
            material.lightmapTexture = lightmap;
            material.lightmapTexture.coordinatesIndex = 1;
            material.useLightmapAsShadowmap = true;
        }
        
        var createScene = function () {
            // scene init
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = BABYLON.Color3.Black();
            var camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, 1.6, 7.6, new BABYLON.Vector3(0,1.5,0), scene);
            camera.minZ = 0.01;
            camera.allowUpsideDown = false;
            camera.wheelPrecision = 150;
            camera.attachControl(canvas, true);
            var hdrTexture = new BABYLON.CubeTexture("textures/Studio_Softbox_2Umbrellas_cube_specular.env", scene);
            hdrTexture.gammaSpace = false;
            scene.environmentTexture = hdrTexture;
            var shaderBall, shaderBallGLTFRoot;
        
            // cornell box
            BABYLON.SceneLoader.ImportMesh(
                "",
                "https://models.babylonjs.com/CornellBox/",
                "cornellBox.glb",
                scene,
                function () {
                    // renaming the default gltf "__root__"
                    scene.getMeshByName("bloc.000").parent.name = "__cornell-root__";
                    // material tweaking
                    scene.materials.forEach(function(material){
                        material.environmentIntensity = 1.4;
                    });
                    scene.getMaterialByName("light.000").emissiveColor = BABYLON.Color3.White(); 
                    var monkeyMtl = scene.getMaterialByName("suzanne.000");
                    monkeyMtl.metallic = 0.64;
                    monkeyMtl.roughness = 0.63;
        
                    // we have to cycles through objects to assign their lightmaps
                    let lightmappedMeshes = ["bloc.000", "suzanne.000", "cornellBox.000"];
                    lightmappedMeshes.forEach(function(mesh){
                        let currentMesh = scene.getNodeByName(mesh);
                        let currentMeshChildren = currentMesh.getChildren();
                        // lightmap texture creation
                        let currentLightmap = new BABYLON.Texture(
                            "https://models.babylonjs.com/CornellBox/" + currentMesh.name + ".lightmap.jpg",
                            scene,
                            false,
                            false);
                        switch(currentMesh.getClassName()){
                            case "Mesh":
                                assignLightmapOnMaterial(currentMesh.material, currentLightmap);
                                break;
                            case "TransformNode": 
                                currentMeshChildren.forEach(function(mesh){
                                    assignLightmapOnMaterial(mesh.material, currentLightmap);
                                });
                                break;  
                        }
                    });
        
                    // all new meshes now receive shadows (shadowGenerator created below)
                    scene.meshes.forEach(function(mesh){
                        mesh.receiveShadows = true;
                    });
            });
        
            // BJS logo 
            BABYLON.SceneLoader.ImportMesh(
                "",
                "https://storage.opensea.io/files/",
                "edd6dcbdb754fce10fbfdd0598ac3adc.glb",
                scene,
                function (shaderBallMeshes) {
                    // selecting the mesh we will animate later on scene.registerBeforeRender()
                    shaderBall = scene.getMeshByID("simpleShaderBall");
                    // renaming the default gltf empty object "__root__" and adapting it to the scene
                    shaderBallGLTFRoot = shaderBall.parent;
                    shaderBallGLTFRoot.name = "__shaderBall-root__";
                    shaderBallGLTFRoot.scaling.scaleInPlace(0.5);
                    shaderBallGLTFRoot.position.y = 3;
                    shaderBallGLTFRoot.rotationQuaternion = null; //this will help for the rotation anim later
                    // tweaking materials
                    var shaderBallMtl = shaderBall.material;
                    shaderBallMtl.albedoTexture = new BABYLON.Texture("textures/checkerBJS.png", scene);
                    shaderBallMtl.metallic = 1;
                    shaderBallMtl.roughness = 0.33;
                    // dyn light to generate shadows 
                    var light = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(0, -1, 0), scene);
                    light.position = new BABYLON.Vector3(0, 3, 0);
                    // shadows handling
                    var shadowGenerator = new BABYLON.ShadowGenerator(128, light);
                    shadowGenerator.useBlurExponentialShadowMap = true;
                    shaderBallMeshes.forEach(function(mesh){
                        shadowGenerator.addShadowCaster(mesh);
                    });
            });
        
            // why not using glow?
            var glowLayer = new BABYLON.GlowLayer("glow", scene, {
                mainTextureFixedSize: 256,
                blurKernelSize: 32
            });
        
            // simple animation for the logo
            var time = 0; //this will be used as a time variable
            scene.registerBeforeRender(function() {
                time += 0.1;
                if(shaderBallGLTFRoot != undefined){
                    shaderBallGLTFRoot.rotation.x += 0.002;
                    shaderBallGLTFRoot.rotation.y -= 0.003;
                    shaderBallGLTFRoot.rotation.z -= 0.001;       
                    shaderBallGLTFRoot.position.y = (Math.cos(time*0.1)*0.15) + 1.5;
                }
            });
        
            return scene;
        };
                var engine;
                var scene;
                initFunction = async function() {               
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        scene = createScene();};
        initFunction().then(() => {sceneToRender = scene        
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
